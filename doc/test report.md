以下是整个项目的测试方案文档，包含了单元测试、集成测试、功能测试和性能测试的各个方面：

---

# 项目测试方案文档

## 一、综述

### 1.1 单元测试综述
单元测试是针对软件中的最小可测试单元（通常是函数或方法）进行的测试，目的是验证每个单元的功能是否符合预期。在本项目中，单元测试主要使用JUnit 5框架，结合Mockito进行模拟对象的创建和行为验证。单元测试可以帮助开发人员在开发过程中尽早发现代码中的问题，提高代码的可靠性和可维护性。

### 1.2 集成测试综述
集成测试是将多个单元组合在一起进行测试，以验证它们之间的交互是否正确。在本项目中，集成测试主要通过Spring Boot的测试工具来模拟真实的运行环境，对不同组件之间的协作进行测试。集成测试可以发现单元测试无法发现的问题，如组件之间的接口不兼容、数据传递错误等。

## 二、测试方案设定

### 2.1 单元测试方案

#### 2.1.1 测试框架和工具
- **JUnit 5**：作为Java单元测试的核心框架，提供了丰富的注解和断言方法，方便编写和执行单元测试。
- **Mockito**：用于创建和配置模拟对象，隔离被测试单元与其他依赖，从而专注于测试单元本身的功能。

#### 2.1.2 测试范围
- 对项目中的各个服务类、工具类的关键方法进行单元测试，确保每个方法在各种输入情况下都能正常工作。例如，`FraudDetectionService`中的`detectFraud`方法，`GcpLoggingService`中的`log`方法等。

#### 2.1.3 测试用例设计原则
- **覆盖所有可能的输入情况**：包括正常输入、边界输入和异常输入。例如，对于交易金额的输入，要测试正常金额、最小金额、最大金额以及负数等情况。
- **验证方法的返回值和副作用**：除了验证方法的返回值是否符合预期，还要检查方法是否产生了预期的副作用，如日志记录、数据库操作等。

#### 2.1.4 示例测试用例
以下是`FraudDetectionServiceTest`类中`testDetectFraud`方法的测试用例示例：

```java
@Test
void testDetectFraud() {
    // 准备测试数据
    Transaction transaction = new Transaction();
    transaction.setTransactionId("txn1");
    transaction.setAccountId("acc123");

    // 调用被测试方法
    String result = fraudDetectionService.detectFraud(transaction);

    // 验证结果
    assertEquals("empty rules", result, "当规则为空时，应返回 'empty rules'");
}
```

### 2.2 集成测试方案

#### 2.2.1 测试框架和工具
- **Spring Boot Test**：提供了丰富的注解和工具，用于模拟Spring Boot应用的运行环境，方便进行集成测试。
- **TestRestTemplate**：用于发送HTTP请求，测试RESTful API的功能。

#### 2.2.2 测试范围
- 对项目中的RESTful API进行集成测试，验证各个接口的功能是否正常。例如，`/fraud/check`接口，测试不同交易请求的响应结果。

#### 2.2.3 测试用例设计原则
- **模拟真实请求**：使用真实的请求数据，模拟用户的实际操作，验证接口的响应是否符合预期。
- **验证接口的正确性和稳定性**：多次发送相同的请求，验证接口的响应是否一致，确保接口的稳定性。

#### 2.2.4 示例测试用例
以下是`FraudDetectionApplicationTest`类中`testCheckFraud_WhitelistRuleTransaction`方法的测试用例示例：

```java
@Test
void testCheckFraud_WhitelistRuleTransaction() {
    // 创建一个正常的交易请求
    Transaction transaction = new Transaction();
    transaction.setTransactionId("txn1");
    transaction.setAccountId("acc123");
    transaction.setAmount( BigDecimal.valueOf(100.50) );

    // 发送 HTTP 请求，并获取响应
    ResponseEntity<String> response = restTemplate.postForEntity("/fraud/check", transaction, String.class);

    // 验证 HTTP 响应状态码和响应内容
    assertEquals(HttpStatus.OK, response.getStatusCode());
    assertEquals("Fraudulent Transaction Detected by Rule: WhitelistRule", response.getBody());
}
```

## 三、功能测试方案

### 3.1 测试目标
验证项目的各个功能是否符合需求规格说明书的要求，确保系统的功能正确性。重点测试以下内容：
- 随机生成交易金额和用户名，验证是否正确触发系统的阈值规则或白名单规则。
- 检查在规则被触发后，系统是否记录日志，并且是否生成相应的告警信息。

### 3.2 测试环境
- **开发环境**：用于开发和调试阶段的功能测试，方便开发人员及时发现和解决问题。
- **测试环境**：模拟生产环境，对系统进行全面的功能测试，确保系统在生产环境中的稳定性和可靠性。

### 3.3 测试用例设计
- **基于需求规格说明书**：根据需求规格说明书中的功能需求，设计相应的测试用例，覆盖所有的功能点。
- **考虑各种输入情况**：包括正常输入、边界输入和异常输入，验证系统在不同情况下的功能表现。
- **随机金额和用户名生成**：通过程序随机生成交易金额和用户名，以确保全面覆盖可能的交易情况。生成的金额将用于验证是否触发阈值规则；生成的用户名将用于验证是否匹配白名单规则。
- **规则触发后验证**：通过系统日志和告警机制，验证当阈值规则或白名单规则被触发时，系统是否记录了日志并发出正确的告警信息。

#### 3.3.1 测试用例示例

**测试用例 1：随机金额测试触发阈值规则**

- **功能概述**：验证是否随机生成的金额触发了阈值规则。
- **测试步骤**：
    1. 随机生成一个交易金额（例如：大于或小于设定的阈值）。
    2. 发送交易请求至 `/fraud/check` 接口。
    3. 系统处理后，验证是否触发阈值规则。
    4. 检查是否生成相关日志，并且阈值规则是否在日志中得到记录。
    5. 验证是否触发了告警。
- **预期结果**：
    - 若交易金额超过阈值，系统应记录“阈值规则”触发的日志，并生成相应的告警信息。
    - 若金额未超过阈值，不应触发阈值规则，日志和告警应为空。

**测试用例 2：随机用户名测试触发白名单规则**

- **功能概述**：验证是否随机生成的用户名匹配白名单规则。
- **测试步骤**：
    1. 随机生成一个交易请求，用户名为白名单中的用户名或非白名单用户名。
    2. 发送交易请求至 `/fraud/check` 接口。
    3. 检查是否触发白名单规则。
    4. 验证触发规则后的日志输出。
    5. 检查是否生成正确的告警。
- **预期结果**：
    - 如果用户名匹配白名单规则，日志中应记录“白名单规则”触发的信息，并且系统应生成相关告警。
    - 如果用户名不在白名单内，系统不应触发白名单规则，且无相关日志和告警。

### 3.4 测试执行
- **手动测试**：对于一些复杂的业务场景，需要手动进行测试，确保系统的功能符合预期。尤其是在规则触发时的日志和告警测试。
- **自动化测试**：对于随机生成的测试数据，可以通过自动化脚本批量执行测试，确保在不同金额和用户名情况下的规则触发行为。
- **日志和告警验证**：每次触发规则后，通过查阅系统日志和告警监控，确保系统记录了正确的日志信息，并根据预设的告警规则生成了警报。

## 四、性能测试方案

### 4.1 测试目标
评估系统在不同负载下的性能表现，找出系统的性能瓶颈，为系统的优化提供依据。

### 4.2 测试环境
- **性能测试环境**：配置与生产环境相似的硬件和软件环境，确保测试结果的准确性。

### 4.3 测试工具
- **JMeter**：一款开源的性能测试工具，可以模拟大量用户并发访问系统，测试系统的性能指标。

### 4.4 测试场景设计
- **并发用户数**：根据系统的预期用户量，设计不同的并发用户数场景，如100用户并发、500用户并发、1000用户并发等。
- **持续时间**：每个场景的测试持续时间根据系统的业务特点和性能要求进行设定，一般为10 - 30分钟。

### 4.5 性能指标
- **响应时间**：系统对用户请求的响应时间，是衡量系统性能的重要指标之一。
- **吞吐量**：系统在单位时间内处理的请求数量，反映了系统的处理能力。
- **错误率**：系统在处理请求过程中出现错误的比例，反映了系统的稳定性。

### 4.6 测试执行
- **逐步增加负载**：从低并发用户数开始，逐步增加并发用户数，观察系统的性能指标变化。
- **分析测试结果**：根据测试结果，分析系统的性能瓶颈，找出需要优化的地方。

---
